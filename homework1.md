1. Define the term essential difficulties as it is used by Brooks. Provide background and context with your answer and at least one example of an essential difficulty.

  **Essential difficulties** refer to the difficulties ‘’inherent in the nature of software’’. These difficulties are essential because every software entity will have to solve the same problems such as data sets, algorithms and functions. An example of essential difficulties in software is a ‘’bug’’ in code.

---

2. Define the term accidental difficulties as it is used by Brooks. Provide background and context with your answer and at least one example of an accidental difficulty.

  **Accidental difficulties** refer to the difficulties encountered during software production which are not related to the nature of software entities. According to Brooks, most of the recent software technology developments, such as high-level language and unified programming environments tackles these accidental difficulties. An example of accidental difficulty is a tool that one software relies on is not compatible with the software after an update.

---

3. List and briefly describe the four essential difficulties of developing software systems that Brooks identifies. Provide additional examples of each type of the four essential difficulties.

* **Complexity**: Software entities are very complex in nature because ‘’no two parts are alike’’. They have many states and elements, and as the software grows, the number of parts and states will grow exponentially with it. 

* **Conformity**: Software must conform with arbitrary rules that used by other institutions or systems. For example, a software for calculating taxes must conform with tax laws in different states and countries.

* **Changeability**: Softwares are constantly pressured to change. This is because changing a software is relatively easy, and software’s long lifecycle requires it to change to work with the new hardware/software.

* **Invisibility**: Softwares are intangible and unvisualizable. It is very difficult to reduce a software entity to simple diagrams. 

---

4. Define what Brooks means by a silver bullet and reconstruct his argument as to why he believes there is no silver bullet for software engineering.

  A **silver bullet** refers to a single development in software engineering technology that can lead to a ‘’order-of-magnitude improvement in productivity’’.

  Brooks said that current breakthroughs in software engineering only tackles the accidental difficulties. In the lecture, it is mentioned that in order to improve software development by a factor of 10, accidental difficulties needs to account for at least 90% of all problems. However, this is not the case in software engineering. Also, in the lecture, it is also mentioned that it is impossible to eliminate all accidental difficulties because solving one problem may lead to another problem in software production. 

---

5. In lecture, software engineering's relationship to computer science was described by analogy by discussing the differences between a chemist (chemistry) and a chemical engineer (chemical engineering). Define software engineering and its relationship to computer science; make use of the chemist vs. chemical engineer analogy when answering this question.

  Chemists often do experiments on a very small scale. A technique discovered in small experiments can be scaled up and used by chemical engineer in other scenarios and can be used to help with planning and budgeting. Computer scientists are like chemist; they will develop new algorithms and new theories that can be utilized by software engineers to make better software.

---

6. In lecture, we discussed the importance of the following concepts to software engineers: abstractions, conversations, specification, translation, and iteration. Define each of these concepts as they are related to software engineering and discuss their importance.

* **Abstraction** is the primary tool used by software engineers to solve problems. It means to break down a problem into wroakble sub-problems, or to use abstractions developed by others.

* **Conversations** refer to the conversations happen among the people who are involved in software production, which can include customers, programmers and designers. This is very important because information is exchanged via conversations.

* **Specifications** is one of the core principle in software engineering. Everything in software engineering needs to be specified: requirements, designs and etc. 

* **Translation** is another core principle in software development. It means to translate software development into something workable for all personnel involved. 

* **Iteration** means that software development are usually done step by step and in multiple iterations. It is important because iterating on a software enables engineers to make improvements on the product.

---
# References

No Silver Bullet: Essence and Accidents of Software Engineering - Frederick P. Brooks, Jr.

Lecture Note #2 - Prof. Ken Anderson
